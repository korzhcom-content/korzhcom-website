"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5570],{2414:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var s=i(8488),t=i(4848),l=i(8453);const o={title:"Using TypeScript with WebPack in ASP.NET Core projects",tags:["ASP-NET-CORE","JAVASCRIPT","TYPESCRIPT"],slug:"typescript-webpack-aspnetcore"},a="Using TypeScript with WebPack in ASP.NET Core projects",r={authorsImageUrls:[]},c=[{value:"Motivation",id:"motivation",level:2},{value:"Solution",id:"solution",level:2},{value:"Getting started",id:"getting-started",level:2},{value:"0. Install Node.JS",id:"0-install-nodejs",level:3},{value:"1. ClientScript sub-folder",id:"1-clientscript-sub-folder",level:3},{value:"2. Add configuration files",id:"2-add-configuration-files",level:3},{value:"3. Add TypeScript files",id:"3-add-typescript-files",level:3},{value:"hello.ts",id:"hellots",level:4},{value:"index.ts",id:"indexts",level:4},{value:"4. Build your library",id:"4-build-your-library",level:3},{value:"5. Attach the final script to your app",id:"5-attach-the-final-script-to-your-app",level:3},{value:"Configuring the scope",id:"configuring-the-scope",level:2},{value:"1. Use module names and their aliases",id:"1-use-module-names-and-their-aliases",level:3},{value:"2. Using namespace clause",id:"2-using-namespace-clause",level:3},{value:"Using third-party libraries",id:"using-third-party-libraries",level:2},{value:"1. Add lodash library to your package.json",id:"1-add-lodash-library-to-your-packagejson",level:3},{value:"2. Import lodash functions in your hello.ts file",id:"2-import-lodash-functions-in-your-hellots-file",level:3},{value:"3. Modify hello() function",id:"3-modify-hello-function",level:3},{value:"Watch mode",id:"watch-mode",level:2},{value:"Conclusions",id:"conclusions",level:2}];function d(e){const n={code:"code",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:i(213).A+"",width:"1055",height:"281"})}),"\n",(0,t.jsx)(n.h2,{id:"motivation",children:"Motivation"}),"\n",(0,t.jsx)(n.p,{children:"Suppose you work on ASP.NET Core web application that solves some business-related tasks. You know, a few forms where users enter their data and get some reports. Although such a project may not require any complex logic on the client, you still probably need to write some JavaScript code to make user interaction with your application more convenient and enjoyable. For example, you may need a simple prompt popup on item deletion since it's not quite right to use a separate page for that. Or, you want to do client-side validation. Or ... it really can be any other client-side task, you name it."}),"\n",(0,t.jsx)(n.p,{children:"Of course, you can add a few lines of script on each page (with vanilla JavaScript or using the good old JQuery) but it is really hard to maintain all these small pieces when your project gets bigger. Moreover, some of these pieces do the same things, so you either need to replicate them in many places (bad decision) or you end up creating a small library that contains all client-side functions, structures, and classes used in your project."}),"\n",(0,t.jsx)(n.p,{children:"This article describes how to create such a JS library for your ASP.NET Core project with minimal effort and in a way that will provide better support for further changes."}),"\n",(0,t.jsx)(n.h2,{id:"solution",children:"Solution"}),"\n",(0,t.jsx)(n.p,{children:"Long story short, we are going to put all our client-side code to separate files (with classes, functions, data structures) and then bundle them with the help of WebPack 5. The resulting script can be included right into your _Layout.cshtml (so, it will be available on all pages of your web app) or you can include it only on the pages where it's necessary."}),"\n",(0,t.jsx)(n.p,{children:"Moreover, we will use TypeScript instead of pure JavaScript because, you know, static typing is good and it allows us to catch a lot of errors at compile time."}),"\n",(0,t.jsx)(n.p,{children:"In addition, you can consider this article as a quick introduction to client-side development. Especially if you are a .NET developer who still tends to stay backend-only and who is afraid of all that fancy client-side stuff (as I was some time ago)."}),"\n",(0,t.jsx)(n.h2,{id:"getting-started",children:"Getting started"}),"\n",(0,t.jsx)(n.p,{children:"Here we will describe the steps necessary to set up the configuration for bundling a small TypeScript library with your own code. For the sake of simplification, this library will contain just one function for now."}),"\n",(0,t.jsx)(n.h3,{id:"0-install-nodejs",children:"0. Install Node.JS"}),"\n",(0,t.jsx)(n.p,{children:"I'm pretty much sure you already have it installed. In case you don't - please do it. We will need Node.JS version 10.13.0 (or newer) on your dev/build machine."}),"\n",(0,t.jsx)(n.h3,{id:"1-clientscript-sub-folder",children:"1. ClientScript sub-folder"}),"\n",(0,t.jsx)(n.p,{children:"We will put all our scripts and configuration files into a separate sub-folder ClientScript of your main project's folder. It's similar to ClientApp sub-folder used in most of the SPA (single page application) templates available for ASP.NET Core."}),"\n",(0,t.jsx)(n.h3,{id:"2-add-configuration-files",children:"2. Add configuration files"}),"\n",(0,t.jsx)(n.p,{children:"We will need 3 configuration files:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"package.json - to define our bundle and all dependencies,"}),"\n",(0,t.jsx)(n.li,{children:"webpack.config.js - for WebPack configuration"}),"\n",(0,t.jsx)(n.li,{children:"tsconfig.json - for TypeScript settings."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"For now, you can just copy these files as-is. We will describe each of them later."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",metastring:'title="package.json"',children:'{\n  "name": "myapp-client-bundle",\n  "version": "1.0.0",\n  "description": "This is client-side scripts bundle for MyApp",\n  "private": true,\n  "scripts": {\n    "build": "webpack --mode=development",\n    "build:prod": "webpack --mode=production"\n  },\n  "devDependencies": {\n    "ts-loader": "^9.2.5",\n    "typescript": "^4.4.3",\n    "webpack": "^5.52.1",\n    "webpack-cli": "^4.8.0"\n  },\n  "dependencies": {\n  }\n}\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",metastring:'title="webpack.config.js"',children:"const path = require('path');\n\nmodule.exports = {\n  entry: './src/index.ts',\n  module: {\n    rules: [\n      {\n        test: /\\.tsx?$/,\n        use: 'ts-loader',\n        exclude: /node_modules/,\n      },\n    ],\n  },\n  resolve: {\n    extensions: ['.tsx', '.ts', '.js'],\n  },\n  output: {\n    library: {\n      name: 'MYAPP',\n      type: 'var'\n    },\n    filename: 'app-client.js',\n    path: path.resolve(__dirname, '../wwwroot/js'),\n  }\n};\n"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",metastring:'title="tsconfig.json"',children:'{\n  "compilerOptions": {\n    "outDir": "./dist/",\n    "noImplicitAny": true,\n    "module": "es6",\n    "target": "es5",\n    "allowJs": true,\n    "moduleResolution": "node"\n  }\n}\n'})}),"\n",(0,t.jsx)(n.h3,{id:"3-add-typescript-files",children:"3. Add TypeScript files"}),"\n",(0,t.jsx)(n.p,{children:"For the sake of simplicity, our library in this initial stage will contain only one function hello() that simply prints Hello world to the browser's console. Here are two files we need for that outstanding :) functionality:"}),"\n",(0,t.jsx)(n.h4,{id:"hellots",children:"hello.ts"}),"\n",(0,t.jsx)(n.p,{children:"This file contains our function packed into the funcs namespace, so we will be able to call it as MYAPP.funcs.hello()"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",metastring:'title="hello.ts"',children:"export namespace funcs {\n    export function hello(): void {\n        const message = 'Hello world!';\n        console.log(message);\n    }\n}\n"})}),"\n",(0,t.jsx)(n.h4,{id:"indexts",children:"index.ts"}),"\n",(0,t.jsx)(n.p,{children:'This is our entry point. This TypeScript file will not contain any functions or classes. It will just define which parts of our code (functions, interfaces, classes, etc) we are going to expose to the outside world. Since we have only one file with "real" functionality our index.ts will as simple as:'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",metastring:'title="index.ts"',children:"export * from './hello';\n"})}),"\n",(0,t.jsxs)(n.p,{children:['and it means that we would to "reveal" all public (exported) parts inside our ',(0,t.jsx)(n.code,{children:"hello.ts"})]}),"\n",(0,t.jsx)(n.h3,{id:"4-build-your-library",children:"4. Build your library"}),"\n",(0,t.jsxs)(n.p,{children:["That's it. We are ready to build our bundle script. To do so, open your terminal program, move to ",(0,t.jsx)(n.code,{children:"ClientScript"})," folder and run the following 2 commands:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"npm install\n"})}),"\n",(0,t.jsx)(n.p,{children:"and then"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"npm run build\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The first one will install all necessary NPM libraries (the ones which are listed in the ",(0,t.jsx)(n.code,{children:"dependencies"})," and ",(0,t.jsx)(n.code,{children:"devDependencies"})," sections of your ",(0,t.jsx)(n.code,{children:"package.json"}),"). You will need to run it before the first build and then only when you add a new dependency (another NPM package) to your ",(0,t.jsx)(n.code,{children:"package.json"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:['The second command actually runs WebPack that compiles (or, to be more correct, "transpiles") your TypeScript files to JavaScript, then bundles all JS code into one file ',(0,t.jsx)(n.code,{children:"app-client.js"})," and puts that file into ",(0,t.jsx)(n.code,{children:"wwwroot/js"})," folder of your web project as defined in ",(0,t.jsx)(n.code,{children:"webpack.config.js"})," configuration file."]}),"\n",(0,t.jsxs)(n.p,{children:["According to the ",(0,t.jsx)(n.code,{children:"output/library"})," section of that file, all functions or structures of your new bundle will be accessible via the ",(0,t.jsx)(n.code,{children:"MYAPP"})," global variable."]}),"\n",(0,t.jsx)(n.h3,{id:"5-attach-the-final-script-to-your-app",children:"5. Attach the final script to your app"}),"\n",(0,t.jsx)(n.p,{children:"To use our script you just need to include it on your page as any other JS file:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:'<script src="/js/app-client.min.js"><\/script>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["You can add that line either to the ",(0,t.jsx)(n.code,{children:"_Layout.cshtml"})," (to make it available on all pages of your web application) or to the view or Razor page where it's necessary."]}),"\n",(0,t.jsx)(n.p,{children:"Now you can call the function(s) from our new JS library:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<script>\nMYAPP.funcs.hello();\n<\/script>\n"})}),"\n",(0,t.jsx)(n.h2,{id:"configuring-the-scope",children:"Configuring the scope"}),"\n",(0,t.jsxs)(n.p,{children:["One of the great features of using TypeScript and WebPack is organizing your code in modules and then combining those modules into namespaces using WebPack's configuration and TypeScript's ",(0,t.jsx)(n.code,{children:"namespace"})," structure."]}),"\n",(0,t.jsx)(n.p,{children:"There are several possible options."}),"\n",(0,t.jsx)(n.h3,{id:"1-use-module-names-and-their-aliases",children:"1. Use module names and their aliases"}),"\n",(0,t.jsx)(n.p,{children:'You can put functions and classes in a module and export that module either "as-is" or with an alias.'}),"\n",(0,t.jsx)(n.p,{children:"For example, if we have the following module:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",metastring:'title="dialogs.ts"',children:"export class Dialog {\n    ... \n}\n\nexport function showDialog() { \n    ...  \n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["and we use this export declaration in our ",(0,t.jsx)(n.code,{children:"index.ts"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export * from './dialogs';\n"})}),"\n",(0,t.jsxs)(n.p,{children:["then our ",(0,t.jsx)(n.code,{children:"Dialog"})," class and ",(0,t.jsx)(n.code,{children:"showDialog()"})," function will be available right under ",(0,t.jsx)(n.code,{children:"MYAPP"})," namespace as ",(0,t.jsx)(n.code,{children:"MYAPP.Dialog"})," and ",(0,t.jsx)(n.code,{children:"MYAPP.showDialog()"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["You can also specify an alias for that ",(0,t.jsx)(n.code,{children:"dialogs"})," module:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export * as dlg from './dialogs';\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Now our class and the function will be accessible as ",(0,t.jsx)(n.code,{children:"MYAPP.dlg.Dialog"})," and ",(0,t.jsx)(n.code,{children:"MYAPP.dlg.showDialog()"})," correspondingly."]}),"\n",(0,t.jsx)(n.h3,{id:"2-using-namespace-clause",children:"2. Using namespace clause"}),"\n",(0,t.jsx)(n.p,{children:"You can also use the namespace clause and then re-export the imported modules, so all functions, variables, and types that belong to the same namespace even in different modules will be merged together."}),"\n",(0,t.jsx)(n.p,{children:"For example, we have the following two modules:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",metastring:'title="dialogs.ts"',children:"export namespace ui {\n    export class Dialog1 {\n        ... \n    }\n\n    export function showDialog1() {\n        ...  \n    }\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"and"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",metastring:'title="widgets.ts"',children:"export namespace ui {\n  export class Widget1 { ... }\n\n  export function renderWidget1() { ... }\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["w, if we place the following two lines in our ",(0,t.jsx)(n.code,{children:"index.ts"})," module:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export * from './dialogs';\nexport * from './widgets';\n"})}),"\n",(0,t.jsxs)(n.p,{children:["we will be able to access all those exported functions and classes under the ",(0,t.jsx)(n.code,{children:"MYAPP.ui"})," namespace. For example: ",(0,t.jsx)(n.code,{children:"MYAPP.ui.renderWidget1()"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"using-third-party-libraries",children:"Using third-party libraries"}),"\n",(0,t.jsx)(n.p,{children:'Maybe the most significant advantage of this setup (that may seem a little complicated for just a "hello world" function) is the possibility to use any third-party JS library from hundred of thousands available on NPM repository.'}),"\n",(0,t.jsxs)(n.p,{children:["As an example, we slightly modify our ",(0,t.jsx)(n.code,{children:"hello()"})," function so that it will take a parameter ",(0,t.jsx)(n.code,{children:"name"})," and will print the phrase ",(0,t.jsx)(n.code,{children:"Hello, {name}"})," to the console. Before printing, the string stored in the name variable will be capitalized with the help of ",(0,t.jsx)(n.code,{children:"capitalize()"})," function from the well-known ",(0,t.jsx)(n.code,{children:"lodash"})," library."]}),"\n",(0,t.jsx)(n.p,{children:"Here are the steps we should take to achieve this goal:"}),"\n",(0,t.jsx)(n.h3,{id:"1-add-lodash-library-to-your-packagejson",children:"1. Add lodash library to your package.json"}),"\n",(0,t.jsx)(n.p,{children:"Just open a terminal inside your ClientScript folder and type:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"npm install lodash\n"})}),"\n",(0,t.jsx)(n.p,{children:"As the result of this operation, you will see something like the following in the dependencies section of your package.json file:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'"dependencies": {\n    "lodash": "^4.17.21"\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"(the actual version number can be different)."}),"\n",(0,t.jsx)(n.h3,{id:"2-import-lodash-functions-in-your-hellots-file",children:"2. Import lodash functions in your hello.ts file"}),"\n",(0,t.jsx)(n.p,{children:"Add the following line at the beginning of hello.ts:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import * as _ from 'lodash';\n"})}),"\n",(0,t.jsx)(n.h3,{id:"3-modify-hello-function",children:"3. Modify hello() function"}),"\n",(0,t.jsx)(n.p,{children:"Now we can use all lodash library functions using _ global variable (this is the default way of using lodash functions since the times it was not an NPM library). So, our hello function will look the following:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export function hello(name : string): void {\n  const message = 'Hello, ' + _.capitalize(name);\n  console.log(message);\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Additionally, we will modify the function call on our page:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-html",children:"<script>\nMYAPP.funcs.hello('sergiy');\n<\/script>\n"})}),"\n",(0,t.jsx)(n.p,{children:"When we rebuild our script (npm run build), run the app, and open the main page, we will see the following string in the console panel of our browser:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Hello, Sergiy\n"})}),"\n",(0,t.jsx)(n.h2,{id:"watch-mode",children:"Watch mode"}),"\n",(0,t.jsx)(n.p,{children:"It's unnecessary to run the build command each time you change something in your script or add a new package to your project. Instead, you can use the watch mode once, and WebPack will re-build your project every time something was changed:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-shell",children:"npm run watch\n"})}),"\n",(0,t.jsx)(n.h2,{id:"conclusions",children:"Conclusions"}),"\n",(0,t.jsx)(n.p,{children:"As we can see, using TypeScript with WebPack to build vanilla JS client-side scripts for your ASP.NET Core projects has a lot of benefits:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Strong-typed TypeScript code with all advantages of the latest JavaScript features: classes, arrow functions, modules, scopes, and promises."}),"\n",(0,t.jsx)(n.li,{children:"Better support by code editors (like Visual Studio Code) with syntax highlighting, IntelliSense, etc."}),"\n",(0,t.jsx)(n.li,{children:"A possibility to use 3-party libraries with typing definitions."}),"\n",(0,t.jsx)(n.li,{children:"More compact and optimized JS 5 code generated by WebPack."}),"\n",(0,t.jsx)(n.li,{children:"Hot reload of the changes you make in the code editor."}),"\n",(0,t.jsx)(n.li,{children:"Better debugging experience (I'm going to write a separate article about it). It's possible to debug your original TypeScript code instead of minimized JS code available for your web app."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"There is one more note. We used WebPack in this article since it's the most popular module bundler for now. However, I believe that we can quickly get the same results with any other bundler like Browserify, Parcel, or Rollup."}),"\n",(0,t.jsx)(n.p,{children:"Please let me know (via my Twitter account @korzhs or here in the comments) if this article was valuable and informative for you."}),"\n",(0,t.jsx)(n.p,{children:"Happy coding!"})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},213:(e,n,i)=>{i.d(n,{A:()=>s});const s=i.p+"assets/images/tswebpack-cover-672556cc437724f80a90b6ab447e918b.jpg"},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(6540);const t={},l=s.createContext(t);function o(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(l.Provider,{value:n},e.children)}},8488:e=>{e.exports=JSON.parse('{"permalink":"/blog/typescript-webpack-aspnetcore","source":"@site/blog/2022-04-19-using-ts-wp-aspnet-core-proj/index.md","title":"Using TypeScript with WebPack in ASP.NET Core projects","description":"Motivation","date":"2022-04-19T00:00:00.000Z","tags":[{"inline":true,"label":"ASP-NET-CORE","permalink":"/blog/tags/asp-net-core"},{"inline":true,"label":"JAVASCRIPT","permalink":"/blog/tags/javascript"},{"inline":true,"label":"TYPESCRIPT","permalink":"/blog/tags/typescript"}],"readingTime":9.21,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"Using TypeScript with WebPack in ASP.NET Core projects","tags":["ASP-NET-CORE","JAVASCRIPT","TYPESCRIPT"],"slug":"typescript-webpack-aspnetcore"},"unlisted":false,"nextItem":{"title":"Single-file web API services with .NET 5 and ASP.NET Core","permalink":"/blog/single-file-web-service-aspnetcore"}}')}}]);