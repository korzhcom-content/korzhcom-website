"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6730],{5166:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var i=n(2647),o=n(4848),s=n(8453);const r={title:"ASP.NET Core default project structure explained (part 2)",tags:["ASP-NET-CORE","PROJECT-TEMPLATE"],slug:"asp-net-core-project-structure-explained-part2"},a="ASP.NET Core default project structure explained (part 2)",d={authorsImageUrls:[]},c=[{value:"Startup class",id:"startup-class",level:2},{value:"Startup class constructor",id:"startup-class-constructor",level:3},{value:"ConfigureServices method",id:"configureservices-method",level:3},{value:"AddDbContext",id:"adddbcontext",level:4},{value:"A few words about the \u201cBuilder\u201d pattern",id:"a-few-words-about-the-builder-pattern",level:5},{value:"AddDefaultIdentity",id:"adddefaultidentity",level:4},{value:"AddRazorPages",id:"addrazorpages",level:3},{value:"Configure method",id:"configure-method",level:2},{value:"Exception handling and security transport",id:"exception-handling-and-security-transport",level:4},{value:"Processing static files (UseStaticFiles)",id:"processing-static-files-usestaticfiles",level:4},{value:"Routing (UseRouting and UseEndpoints)",id:"routing-userouting-and-useendpoints",level:4},{value:"Authentication/Authorization (UseAuthentication, UseAuthorization)",id:"authenticationauthorization-useauthentication-useauthorization",level:4},{value:"Wrapping Up",id:"wrapping-up",level:2}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",h5:"h5",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{src:n(7084).A+"",width:"1920",height:"1442"})}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:["This is the second part of the ",(0,o.jsx)(t.a,{href:"asp-net-core-default-project-structure-explained-part-1",children:"article"}),", where we take apart the default ASP.NET Core solution template piece by piece and try to explain the purpose of each part and how exactly it works. You can consider it as a reference where you can check why a particular part was added to your project and find a link to the relevant documentation that explains it in detail."]}),"\n"]}),"\n",(0,o.jsx)(t.h2,{id:"startup-class",children:"Startup class"}),"\n",(0,o.jsx)(t.p,{children:"As we already mentioned in the first article, the Startup class is the entry point for all initialization codes in your application.\nLong story short, the Startup defines what your application will do and how exactly it will work."}),"\n",(0,o.jsx)(t.p,{children:"By default, any Startup class in the ASP.NET Core application includes three main parts:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"The constructor"})," where you can define some internal variables, set up some configuration settings, or perform application-wide initializations. For example, we suggest our users set here their license keys for our EasyQuery library."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"ConfigureServices"})," method. Here we register all necessary services in the DI (dependency injection) container and define the configuration settings for some of them. In case you are not aware of what Dependency Injection is, here is an article on our blog that explains this concept in simple words."]}),"\n"]}),"\n",(0,o.jsxs)(t.li,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Configure"})," method. This is the stage when you set up the middleware pipeline for your project."]}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Both ",(0,o.jsx)(t.code,{children:"ConfigureServices"})," and ",(0,o.jsx)(t.code,{children:"Configure"})," methods are called automatically while the application starts. You just need to define the services and the middlewares there correspondingly."]}),"\n",(0,o.jsx)(t.p,{children:"Now, let\u2019s take a look at each of these sections more in detail."}),"\n",(0,o.jsx)(t.h3,{id:"startup-class-constructor",children:"Startup class constructor"}),"\n",(0,o.jsx)(t.p,{children:"The default ASP.NET Core project template contains only the following one line of code in the constructor:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:"        public Startup(IConfiguration configuration)\n        {\n            Configuration = configuration;\n        }\n"})}),"\n",(0,o.jsxs)(t.p,{children:["It just saves in the class property the ",(0,o.jsx)(t.a,{href:"https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration/?view=aspnetcore-3.1",children:"configuration object"}),"\npassed here by the DI container, so we can use it in other methods.\nIn the ",(0,o.jsx)(t.a,{href:"https://korzh.com/blog/asp-net-core-project-structure-explained-part1",children:"first article"}),",\nwe have already considered the configuration mechanism used in ASP.NET Core applications."]}),"\n",(0,o.jsx)(t.h3,{id:"configureservices-method",children:"ConfigureServices method"}),"\n",(0,o.jsxs)(t.p,{children:["As it was mentioned before, the ",(0,o.jsx)(t.code,{children:"ConfigureServices"})," method contains the function calls that register different application services in the DI container.\nThese can be authentication/authorization services, MVC or Razor Pages engine, the classes for working with DB, or any other possible services."]}),"\n",(0,o.jsxs)(t.p,{children:["The only parameter of the ",(0,o.jsx)(t.code,{children:"ConfigureServices"})," method has ",(0,o.jsx)(t.code,{children:"IServiceCollection"})," type that represents a list of ",(0,o.jsx)(t.code,{children:"ServiceDescriptor"})," items.\nEach of those items maps some type (usually an interface) to a particular implementation of this type."]}),"\n",(0,o.jsxs)(t.p,{children:["According to the interface, we can use only usual ",(0,o.jsx)(t.code,{children:"IList"})," or ",(0,o.jsx)(t.code,{children:"ICollection"})," functions like ",(0,o.jsx)(t.code,{children:"Add"}),", ",(0,o.jsx)(t.code,{children:"AddRange"}),", ",(0,o.jsx)(t.code,{children:"Remove"}),", and other methods.\nHowever, as you have already noticed, ",(0,o.jsx)(t.code,{children:"ConfigureServices"})," contains such calls as ",(0,o.jsx)(t.code,{children:"services.AddDbContext"}),", ",(0,o.jsx)(t.code,{children:"services.AddRazorPages"}),", and similar.\nYou may ask, \u201cHow is it possible?\u201d The answer is ",(0,o.jsx)(t.strong,{children:"extension methods"}),". Each sub-system used in our project (like Entity Framework Core or MVC engine) defines an extension method (sometimes even a few) for the ",(0,o.jsx)(t.code,{children:"IServiceCollection"})," interface to simplify the registration in the DI and configuration of the services available in that sub-system."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"NB"}),": Please note that the order of the services you register in the ",(0,o.jsx)(t.code,{children:"ConfigureServices"})," method is not important.\nThis method is executed only once upon your application start."]}),"\n",(0,o.jsx)(t.p,{children:"So, let's take a closer look at the default ConfigureServices\u2019 content."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'public void ConfigureServices(IServiceCollection services)\n{\n    services.AddDbContext<ApplicationDbContext>(options =>\n        options.UseSqlServer(\n            Configuration.GetConnectionString("DefaultConnection")));\n    services.AddDefaultIdentity<IdentityUser>(options => options.SignIn.RequireConfirmedAccount = true)\n        .AddEntityFrameworkStores<ApplicationDbContext>();\n    services.AddRazorPages();\n}\n'})}),"\n",(0,o.jsxs)(t.p,{children:["So, there are only three calls there: ",(0,o.jsx)(t.code,{children:"AddDbContext"}),", ",(0,o.jsx)(t.code,{children:"AddDefaultIdentity"}),", and ",(0,o.jsx)(t.code,{children:"AddRazorPages"}),". Let\u2019s inspect each of them separately."]}),"\n",(0,o.jsx)(t.h4,{id:"adddbcontext",children:"AddDbContext"}),"\n",(0,o.jsxs)(t.p,{children:["This method is provided by the ",(0,o.jsx)(t.a,{href:"https://docs.microsoft.com/en-us/ef/core/",children:"Entity Framework Core"})," framework. It registers and configures our database context. The ",(0,o.jsx)(t.code,{children:"Action"}),"delegate passed in the parameter allows us to define the parameters of this DbContext. For example, with ",(0,o.jsx)(t.code,{children:"UseSqlServer"})," call, we tell our DbContext to use a particular type of connection (",(0,o.jsx)(t.code,{children:"SqlConnection"}),") with a particular connection string. The connection string itself is taken from the configuration so it can be easily changed in Development or Production environments. You can find the default connection string in the ",(0,o.jsx)(t.code,{children:"appsettings.json"})," configuration file, which we already analyzed in the ",(0,o.jsx)(t.a,{href:"https://korzh.com/blog/asp-net-core-project-structure-explained-part1",children:"first article"}),"."]}),"\n",(0,o.jsx)(t.h5,{id:"a-few-words-about-the-builder-pattern",children:"A few words about the \u201cBuilder\u201d pattern"}),"\n",(0,o.jsx)(t.p,{children:"You may have noticed an interesting way of passing settings for DbContext.\nInstead of sending an object with options, we use a procedure (Action) with one-parameter options of the DbContextOptionsBuilder type."}),"\n",(0,o.jsxs)(t.p,{children:["That's because, to construct the DbContext settings properly, Entity Framework Core uses the ",(0,o.jsx)(t.strong,{children:"Builder Pattern"}),".\nThis pattern is helpful when you need to perform several steps to construct some complex objects and simply defining a class or structure is not enough. For example, when you need to call some methods depending on the settings in the configuration.\nAs it happens in our case with ",(0,o.jsx)(t.code,{children:"UseSqlServer()"}),"."]}),"\n",(0,o.jsx)(t.p,{children:"There is one more reason why we use a delegate (function) instead of a plain object.\nThere may be a situation when you don't need that service (DbContext) at all.\nFor example, your web app has some actions that do not require database access.\nThe DbContext object will never be created for such requests, and so, we will not need to set its options.\nThe good thing about a delegate is that it can be called exactly when you need to construct the necessary object."}),"\n",(0,o.jsx)(t.p,{children:"I paid so much attention to this pattern because it is used quite often,\nespecially in the process of registering services in DI (and we will use that for the next function call as well)."}),"\n",(0,o.jsx)(t.h4,{id:"adddefaultidentity",children:"AddDefaultIdentity"}),"\n",(0,o.jsxs)(t.p,{children:["The second function call in the ConfigureServices was added here because of the Authentication option we turned on when creating our project.\nIt registers a bunch of services for authentication and authorization tasks such as ",(0,o.jsx)(t.code,{children:"IUserStore"}),", ",(0,o.jsx)(t.code,{children:"IRoleStore"}),", ",(0,o.jsx)(t.code,{children:"IPasswordHasher"}),", ",(0,o.jsx)(t.code,{children:"UserManager"}),", ",(0,o.jsx)(t.code,{children:"SignInManager"}),", and many others.\nThe are all part of the ASP.NET Core Identity sub-system."]}),"\n",(0,o.jsx)(t.p,{children:"This method also uses the Builder Pattern, but in a slightly different way. Instead of passing the builder in the delegate\u2019s parameter, this function returns an IdentityBuilder object, so you can call other functions with simple chaining."}),"\n",(0,o.jsxs)(t.p,{children:["The only function called there is ",(0,o.jsx)(t.code,{children:"AddEntityFrameworkStores"}),".\nIt tells ASP.NET Identity where to store all the entities required for auth tasks (users, roles, claims, etc.).\nAs the name of the method suggests, we will use our Entity Framework services for these tasks.\nThe type of parameter in this method (between ",(0,o.jsx)(t.code,{children:"< .. >"}),") defines the ",(0,o.jsx)(t.code,{children:"DbContext"})," class used to store all auth objects."]}),"\n",(0,o.jsx)(t.h3,{id:"addrazorpages",children:"AddRazorPages"}),"\n",(0,o.jsxs)(t.p,{children:["The last function call in the ",(0,o.jsx)(t.code,{children:"ConfigureServices"})," adds the services necessary for Razor Pages engine.\nIt appears here because of the template we chose at the beginning.\nIf we had selected a template with Model-View-Controller approach at that point, we would have had something like ",(0,o.jsx)(t.code,{children:"services.AddMvc()"})," here."]}),"\n",(0,o.jsx)(t.h2,{id:"configure-method",children:"Configure method"}),"\n",(0,o.jsx)(t.p,{children:"The last method in the Startup class defines the middleware pipeline of our ASP.NET Core program.\nIf you don't know what a middleware pipeline is, you might want to learn more about it because it determines how your web application handles HTTP requests."}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.img,{alt:"ASP.NET Core middleware pipeline",src:n(8015).A+"",width:"600",height:"384"})}),"\n",(0,o.jsxs)(t.p,{children:["Unlike the services registered in ",(0,o.jsx)(t.code,{children:"ConfigureServices"})," (remember, their order is not important), the order of middlewares defined in ",(0,o.jsx)(t.code,{children:"Configure"})," has crucial significance. As you can see from the picture above, the first defined middleware is called for each request while every next one in the pipeline processes only those requests that were not processed by the middlewares defined before it."]}),"\n",(0,o.jsx)(t.p,{children:"So at the beginning of the pipeline, we need to place the middlewares that are necessary for auxiliary tasks (like logging or authentication) and that don\u2019t consume a lot of memory and processing time."}),"\n",(0,o.jsx)(t.p,{children:"Let\u2019s take a look at the default implementation of this method for the chosen project template:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{children:'        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\n        {\n            if (env.IsDevelopment()) {\n                app.UseDeveloperExceptionPage();\n                app.UseDatabaseErrorPage();\n            }\n            else {\n                app.UseExceptionHandler("/Error");\n                app.UseHsts();\n            }\n\n            app.UseHttpsRedirection();\n            app.UseStaticFiles();\n\n            app.UseRouting();\n\n            app.UseAuthentication();\n            app.UseAuthorization();\n\n            app.UseEndpoints(endpoints => {\n                endpoints.MapRazorPages();\n            });\n        }\n'})}),"\n",(0,o.jsx)(t.p,{children:"So, let\u2019s go through the middlewares defined here one by one."}),"\n",(0,o.jsx)(t.h4,{id:"exception-handling-and-security-transport",children:"Exception handling and security transport"}),"\n",(0,o.jsx)(t.p,{children:"The first lines define different middlewares for Development and Production modes.\nIf we are in the Development mode, we define the middlewares that catch all exceptions in the pipeline\nand show a special page with extra information about the error (exception message, stack trace, etc.)."}),"\n",(0,o.jsx)(t.p,{children:"It's possible to do because (as you can see from the image above) the processing of the request is returned to the first middleware\nin the pipeline before being sent back to the client."}),"\n",(0,o.jsx)(t.p,{children:"In the Production mode, we also catch all exceptions and then re-execute the request with the specified path (\u2018/Error\u2019 in our case)."}),"\n",(0,o.jsxs)(t.p,{children:["The second call executed only in Production is ",(0,o.jsx)(t.code,{children:"UseHsts"}),". It adds a middleware that implements HTTP Strict Transport Security Protocol."]}),"\n",(0,o.jsxs)(t.p,{children:["The next in the pipeline is HTTPS redirection middleware (",(0,o.jsx)(t.code,{children:"app.UseHttpsRedirection"}),").\nThe name is self-explanatory. It just redirects all HTTP requests to HTTPS ones.\nThese two middlewares (",(0,o.jsx)(t.code,{children:"app.UseHsts"})," and ",(0,o.jsx)(t.code,{children:"app.UseHttpsRedirection"})," calls) are added because of the ",(0,o.jsx)(t.strong,{children:"Configure for HTTPS"})," option we turned on (actually, it was turned on by default) during the project creation."]}),"\n",(0,o.jsx)(t.h4,{id:"processing-static-files-usestaticfiles",children:"Processing static files (UseStaticFiles)"}),"\n",(0,o.jsxs)(t.p,{children:["The next middleware (added by the ",(0,o.jsx)(t.code,{children:"app.UseStaticFiles()"})," call) takes care of all static files.\nSimply put, if the application gets a request for some .js, .css, or an image file (.png, .jpg, etc.),\nthis middleware looks for a file with the requested name inside ",(0,o.jsx)(t.code,{children:"wwwroot"})," folder and returns it in response (if the file was found).\nIf not, it sends back a response with a 404 status code (\u201cnot found\u201d)."]}),"\n",(0,o.jsxs)(t.p,{children:["There are overloads of ",(0,o.jsx)(t.code,{children:"UseStaticFiles"})," that allow us to define another root folder for static files and set some other options."]}),"\n",(0,o.jsx)(t.h4,{id:"routing-userouting-and-useendpoints",children:"Routing (UseRouting and UseEndpoints)"}),"\n",(0,o.jsx)(t.p,{children:"The next pair of middlewares are, maybe, the most important ones in the pipeline, since they define the routing for all other endpoints in your web app."}),"\n",(0,o.jsx)(t.p,{children:"In simple words, they match a particular request to a particular endpoint, a piece of executable code that handles the request."}),"\n",(0,o.jsx)(t.p,{children:"So, how exactly does it work?"}),"\n",(0,o.jsxs)(t.p,{children:["In the ",(0,o.jsx)(t.code,{children:"Configure"})," method, we call ",(0,o.jsx)(t.code,{children:"app.UseRouting()"})," to add ",(0,o.jsx)(t.code,{children:"EndpointRoutingMiddleware"})," to our pipeline."]}),"\n",(0,o.jsxs)(t.p,{children:["After that, we call ",(0,o.jsx)(t.code,{children:"app.UseEndpoints()"})," to add ",(0,o.jsx)(t.code,{children:"EndpointMiddleware"})," to the pipeline and define the endpoints. Each endpoint is an object that contains (as mentioned above) a delegate (so, a piece of code) that actually handles the request, plus some metadata (like an authorization policy)."]}),"\n",(0,o.jsxs)(t.p,{children:["We can use such extension methods as ",(0,o.jsx)(t.code,{children:"MapGet"}),", ",(0,o.jsx)(t.code,{children:"MapPost"}),", and others to add an endpoint that matches a particular request path or a path template. For example, the following pattern ",(0,o.jsx)(t.code,{children:"/something/{path*}"}),", will be matched for all requests started with ",(0,o.jsx)(t.code,{children:"/something/"}),"."]}),"\n",(0,o.jsxs)(t.p,{children:["Additionally, other services can define their own extension functions that are used to create necessary endpoints. For example, you can use the ",(0,o.jsx)(t.code,{children:"MapRazorPages"})," function for Razor Pages or ",(0,o.jsx)(t.code,{children:"MapHub"})," for SingleR. In our ",(0,o.jsx)(t.a,{href:"https://github.com/KorzhCom/EasyData",children:"EasyData library"})," we defined ",(0,o.jsx)(t.code,{children:"MapEasyData"})," function that adds an endpoint for the API that processes all CRUD operations."]}),"\n",(0,o.jsxs)(t.p,{children:["When our web app gets a new request (and it\u2019s not processed by any middleware defined before ",(0,o.jsx)(t.code,{children:"UseRouting"}),"), the ",(0,o.jsx)(t.code,{children:"EndpointRoutingMiddleware"})," matches it to some endpoint. So, one endpoint among all defined at the application start is becoming selected at that moment."]}),"\n",(0,o.jsxs)(t.p,{children:["Then ",(0,o.jsx)(t.code,{children:"EndpointMiddleware"})," actually calls the endpoint\u2019s delegate to handle the request.\nOther middlewares that are added after ",(0,o.jsx)(t.code,{children:"app.UseRouting()"})," but before ",(0,o.jsx)(t.code,{children:"app.UseEnpoints()"})," can see which endpoint is selected\nand can change something (e.g., to apply an authorization policy) before ",(0,o.jsx)(t.code,{children:"EndpointMiddleware"})," dispatches to the selected endpoint."]}),"\n",(0,o.jsx)(t.h4,{id:"authenticationauthorization-useauthentication-useauthorization",children:"Authentication/Authorization (UseAuthentication, UseAuthorization)"}),"\n",(0,o.jsxs)(t.p,{children:["These two middlewares are added in the ",(0,o.jsx)(t.code,{children:"Configure"})," because of the Authentication option we turned on when we created our project.\nAs already mentioned above, they already know which endpoint is selected and so can add some additional identity-related information to the request\u2019s context (like filling its ",(0,o.jsx)(t.code,{children:"User"})," property) or redirect to the \u201csign-in/sign up\u201d pages if the current request is anonymous but the selected endpoint requires authorization."]}),"\n",(0,o.jsx)(t.h2,{id:"wrapping-up",children:"Wrapping Up"}),"\n",(0,o.jsx)(t.p,{children:"So, in this article, I tried to cover all pieces of one of the most-used ASP.NET Core application templates and figure out why they are used and how they work (from a very general point of view)."}),"\n",(0,o.jsx)(t.p,{children:"I hope this information will help you better understand the internal mechanism of the ASP.NET Core framework and make your code more clear and efficient."}),"\n",(0,o.jsx)(t.p,{children:"Thanks for the reading, and take care!"})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8015:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/aspnetcore-middleware-pipeline-87128c7f53aac03d773e86a0c4903c4c.png"},7084:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/computer-coffee-02-3db0865179d3b5ebf4e4295b5b74d3ca.jpg"},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var i=n(6540);const o={},s=i.createContext(o);function r(e){const t=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:t},e.children)}},2647:e=>{e.exports=JSON.parse('{"permalink":"/blog/asp-net-core-project-structure-explained-part2","source":"@site/blog/2020-08-10-asp-net-core-project-structure-explained-part2/index.md","title":"ASP.NET Core default project structure explained (part 2)","description":"This is the second part of the article, where we take apart the default ASP.NET Core solution template piece by piece and try to explain the purpose of each part and how exactly it works. You can consider it as a reference where you can check why a particular part was added to your project and find a link to the relevant documentation that explains it in detail.","date":"2020-08-10T00:00:00.000Z","tags":[{"inline":true,"label":"ASP-NET-CORE","permalink":"/blog/tags/asp-net-core"},{"inline":true,"label":"PROJECT-TEMPLATE","permalink":"/blog/tags/project-template"}],"readingTime":10.075,"hasTruncateMarker":true,"authors":[],"frontMatter":{"title":"ASP.NET Core default project structure explained (part 2)","tags":["ASP-NET-CORE","PROJECT-TEMPLATE"],"slug":"asp-net-core-project-structure-explained-part2"},"unlisted":false,"prevItem":{"title":"CRUD operations in ASP.NET Core with EasyData library","permalink":"/blog/crud-asp-net-core-with-easydata"},"nextItem":{"title":"ASP.NET Core default project structure explained (part 1)","permalink":"/blog/asp-net-core-project-structure-explained-part-1"}}')}}]);